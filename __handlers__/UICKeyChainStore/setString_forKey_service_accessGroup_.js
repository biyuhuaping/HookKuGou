/*
 * Auto-generated by Frida. Please modify to match the signature of +[UICKeyChainStore setString:forKey:service:accessGroup:].
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */// æ ¹æ®ç±»åž‹æ ¼å¼åŒ–è¾“å‡º Objective-C å¯¹è±¡
function formatObjCObject(objcObj) {
  if (!objcObj || objcObj.isNull()) {
    return 'nil';
  }
  
  const className = objcObj.$className;
  let output = '';
  
  try {
    // NSString ç±»åž‹
    if (className === 'NSString' || className === '__NSCFString' || className === '__NSCFConstantString' || className === 'NSMutableString') {
      output = objcObj.toString();
    }
    // NSData ç±»åž‹
    else if (className === 'NSData' || className === '__NSCFData' || className === 'NSMutableData') {
      const dataLength = objcObj.length();
      const dataBytes = objcObj.bytes();
      
      // å°è¯• UTF-8 å­—ç¬¦ä¸²
      try {
        const utf8String = Memory.readUtf8(dataBytes, Math.min(dataLength, 256));
        const isPrintable = /^[\x20-\x7E\s]*$/.test(utf8String);
        if (isPrintable && utf8String.length > 0 && dataLength <= 256) {
          output = `UTF-8: ${utf8String}`;
        } else {
          // æ˜¾ç¤ºåå…­è¿›åˆ¶
          const hexString = Memory.readByteArray(dataBytes, Math.min(dataLength, 64))
            .map(b => ('0' + (b & 0xFF).toString(16)).slice(-2))
            .join(' ');
          output = dataLength <= 64 ? `Hex: ${hexString}` : `Hex (first 64 bytes): ${hexString}... (total: ${dataLength})`;
        }
      } catch (e) {
        // UTF-8 å¤±è´¥ï¼Œæ˜¾ç¤ºåå…­è¿›åˆ¶
        const hexString = Memory.readByteArray(dataBytes, Math.min(dataLength, 64))
          .map(b => ('0' + (b & 0xFF).toString(16)).slice(-2))
          .join(' ');
        output = dataLength <= 64 ? `Hex: ${hexString}` : `Hex (first 64 bytes): ${hexString}... (total: ${dataLength})`;
      }
    }
    // NSNumber ç±»åž‹
    else if (className === 'NSNumber' || className === '__NSCFNumber') {
      output = objcObj.toString();
    }
    // NSDictionary ç±»åž‹
    else if (className === 'NSDictionary' || className === '__NSCFDictionary' || className === 'NSMutableDictionary') {
      output = objcObj.toString();
    }
    // NSArray ç±»åž‹
    else if (className === 'NSArray' || className === '__NSCFArray' || className === 'NSMutableArray') {
      const count = objcObj.count();
      output = `Array[${count}]: ${objcObj.toString()}`;
    }
    // Block ç±»åž‹
    else if (className === '__NSStackBlock__' || className === '__NSMallocBlock__' || className === '__NSGlobalBlock__') {
      output = objcObj.toString();
    }
    // å…¶ä»–ç±»åž‹ï¼Œä½¿ç”¨ toString()
    else {
      output = objcObj.toString();
    }
  } catch (e) {
    output = `[Error: ${e}] ${objcObj.toString()}`;
  }
  
  return `${output} (${className})`;
}



defineHandler({
  onEnter(log, args, state) {
    log(`+[UICKeyChainStore setString:${args[2]} forKey:${args[3]} service:${args[4]} accessGroup:${args[5]}]`);
    let objcObj1 = new ObjC.Object(args[2]);
    const objcObj2 = new ObjC.Object(args[3]);
    const objcObj3 = new ObjC.Object(args[4]);
    log('ðŸ‘‰ args[2]:' + `${objcObj1.toString()} (${objcObj1.$className})`); 
    log('ðŸ‘‰ args[3]:' + `${objcObj2.toString()} (${objcObj2.$className})`);
    log('ðŸ‘‰ args[4]:' + `${objcObj3.toString()} (${objcObj3.$className})`);
    log('ðŸ‘‰ args[5]:' + args[5]);
    log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\n') + '\n');
  },
  onLeave(log, retval, state) {
    
  }
});
