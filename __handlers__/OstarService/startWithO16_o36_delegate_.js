/*
 * Auto-generated by Frida. Please modify to match the signature of -[OstarService startWithO16:o36:delegate:].
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */// æ ¹æ®ç±»åž‹æ ¼å¼åŒ–è¾“å‡º Objective-C å¯¹è±¡
function formatObjCObject(objcObj) {
  if (!objcObj || objcObj.isNull()) {
    return 'nil';
  }
  
  const className = objcObj.$className;
  let output = '';
  
  try {
    // NSString ç±»åž‹
    if (className === 'NSString' || className === '__NSCFString' || className === '__NSCFConstantString' || className === 'NSMutableString') {
      output = objcObj.toString();
    }
    // NSData ç±»åž‹
    else if (className === 'NSData' || className === '__NSCFData' || className === 'NSMutableData') {
      const dataLength = objcObj.length();
      const dataBytes = objcObj.bytes();
      
      // å°è¯• UTF-8 å­—ç¬¦ä¸²
      try {
        const utf8String = Memory.readUtf8(dataBytes, Math.min(dataLength, 256));
        const isPrintable = /^[\x20-\x7E\s]*$/.test(utf8String);
        if (isPrintable && utf8String.length > 0 && dataLength <= 256) {
          output = `UTF-8: ${utf8String}`;
        } else {
          // æ˜¾ç¤ºåå…­è¿›åˆ¶
          const hexString = Memory.readByteArray(dataBytes, Math.min(dataLength, 64))
            .map(b => ('0' + (b & 0xFF).toString(16)).slice(-2))
            .join(' ');
          output = dataLength <= 64 ? `Hex: ${hexString}` : `Hex (first 64 bytes): ${hexString}... (total: ${dataLength})`;
        }
      } catch (e) {
        // UTF-8 å¤±è´¥ï¼Œæ˜¾ç¤ºåå…­è¿›åˆ¶
        const hexString = Memory.readByteArray(dataBytes, Math.min(dataLength, 64))
          .map(b => ('0' + (b & 0xFF).toString(16)).slice(-2))
          .join(' ');
        output = dataLength <= 64 ? `Hex: ${hexString}` : `Hex (first 64 bytes): ${hexString}... (total: ${dataLength})`;
      }
    }
    // NSNumber ç±»åž‹
    else if (className === 'NSNumber' || className === '__NSCFNumber') {
      output = objcObj.toString();
    }
    // NSDictionary ç±»åž‹
    else if (className === 'NSDictionary' || className === '__NSCFDictionary' || className === 'NSMutableDictionary') {
      output = objcObj.toString();
    }
    // NSArray ç±»åž‹
    else if (className === 'NSArray' || className === '__NSCFArray' || className === 'NSMutableArray') {
      const count = objcObj.count();
      output = `Array[${count}]: ${objcObj.toString()}`;
    }
    // Block ç±»åž‹
    else if (className === '__NSStackBlock__' || className === '__NSMallocBlock__' || className === '__NSGlobalBlock__') {
      output = objcObj.toString();
    }
    // å…¶ä»–ç±»åž‹ï¼Œä½¿ç”¨ toString()
    else {
      output = objcObj.toString();
    }
  } catch (e) {
    output = `[Error: ${e}] ${objcObj.toString()}`;
  }
  
  return `${output} (${className})`;
}



defineHandler({
  onEnter(log, args, state) {
    log(`-[OstarService startWithO16:${args[2]} o36:${args[3]} delegate:${args[4]}]`);
    let objcObj1 = new ObjC.Object(args[2]);
    const objcObj2 = new ObjC.Object(args[3]);
    const objcObj3 = new ObjC.Object(args[4]);
    log('ðŸ‘‰ ' + formatObjCObject(objcObj1));
    log('ðŸ‘‰ ' + formatObjCObject(objcObj2));
    log('ðŸ‘‰ ' + formatObjCObject(objcObj3));
    //è°ƒç”¨æ ˆ
    log('stack: '+ Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\n'));
  },

  onLeave(log, retval, state) {
    const objcObj = new ObjC.Object(retval);
    log('ðŸ‘ˆ: ' + objcObj.toString() + 'ï¼ˆ' + objcObj.$className + 'ï¼‰' + '\n');
  }
});
