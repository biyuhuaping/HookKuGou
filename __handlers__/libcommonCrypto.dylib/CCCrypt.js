/*
 * Auto-generated by Frida. Please modify to match the signature of CCCrypt.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

defineHandler(/**
  * 完整的十六进制+文本显示的CCCrypt监控脚本
  * 数据同时展示十六进制和可打印文本，不包含二进制格式
  */
 {
     onEnter(log, args, state) {
         // 解析基础参数
         const op = args[0].toInt32();
         const alg = args[1].toInt32();
         const options = args[2].toInt32();
         const keyAddr = args[3];
         const keyLen = args[4].toInt32();
         const ivAddr = args[5];
         const dataInAddr = args[6];
         const dataInLen = args[7].toInt32();
  
         // 解析算法名称
         let algorithmName;
         switch (alg) {
             case 0: algorithmName = 'AES(kCCAlgorithmAES)'; break;
             case 1: algorithmName = 'DES(kCCAlgorithmDES)'; break;
             case 2: algorithmName = '3DES(kCCAlgorithm3DES)'; break;
             case 3: algorithmName = 'CAST(kCCAlgorithmCAST)'; break;
             case 4: algorithmName = 'RC4(kCCAlgorithmRC4)'; break;
             case 5: algorithmName = 'RC2(kCCAlgorithmRC2)'; break;
             default: algorithmName = `未知算法(${alg})`;
         }
  
         // 解析选项参数
         const mode = options & 0x0F;
         let modeName;
         switch (mode) {
             case 1: modeName = 'CBC(kCCOptionModeCBC)'; break;
             case 2: modeName = 'ECB(kCCOptionModeECB)'; break;
             case 3: modeName = 'CFB(kCCOptionModeCFB)'; break;
             case 4: modeName = 'OFB(kCCOptionModeOFB)'; break;
             case 5: modeName = 'CTR(kCCOptionModeCTR)'; break;
             case 6: modeName = 'GCM(kCCOptionModeGCM)'; break;
             default: modeName = `未知模式(0x${mode.toString(16)})`;
         }
  
         const padding = options & 0xF0;
         const paddingName = padding === 0x10 
             ? 'PKCS7填充(kCCPaddingPKCS7)' 
             : padding === 0x00 
                 ? '无填充(kCCPaddingNone)' 
                 : `未知填充(0x${padding.toString(16)})`;
  
         // 打印函数调用基本信息
         log('=== CCCrypt 调用开始 ===');
         log(`操作类型: ${op === 0 ? '加密(kCCEncrypt)' : '解密(kCCDecrypt)'}`);
         log(`算法类型: ${algorithmName}`);
         log(`选项参数: 0x${options.toString(16)}`);
         log(`  加密模式: ${modeName}`);
         log(`  填充方式: ${paddingName}`);
         log(`密钥长度: ${keyLen}字节`);
         log(`输入长度: ${dataInLen}字节`);
  
         // 打印密钥（十六进制+文本）
         if (keyAddr && !keyAddr.isNull() && keyLen > 0) {
             log('\n[密钥数据] (十六进制+可打印文本)');
             log(hexdump(keyAddr, {
                 length: keyLen,
                 header: false,
                 ansi: true,
                 format: 'hex+ascii' // 同时显示十六进制和ASCII文本
             }));
         }
  
         // 打印IV（十六进制+文本）
         if (ivAddr && !ivAddr.isNull()) {
             log('\n[IV数据] (十六进制+可打印文本)');
             log(hexdump(ivAddr, {
                 length: 16,
                 header: false,
                 ansi: true,
                 format: 'hex+ascii'
             }));
         }
  
         // 打印输入数据（十六进制+文本）
         if (dataInAddr && !dataInAddr.isNull() && dataInLen > 0) {
             const showLen = Math.min(dataInLen, 256);
             log(`\n[输入数据] (共${dataInLen}字节，显示前${showLen}字节)`);
             log(hexdump(dataInAddr, {
                 length: showLen,
                 header: false,
                 ansi: true,
                 format: 'hex+ascii'
             }));
         }
  
         // 保存输出参数引用
         this.dataOutAddr = args[8];
         this.dataOutLenPtr = args[10];
     },
  
     onLeave(log, retval, state) {
         // 打印执行结果
         const status = retval.toInt32();
         log(`\n[执行结果] 状态码: ${status} (${status === 0 ? '成功' : '失败'})`);
  
         // 打印输出数据（十六进制+文本）
         if (this.dataOutAddr && !this.dataOutAddr.isNull() && this.dataOutLenPtr) {
             const outLen = this.dataOutLenPtr.readUInt();
             if (outLen > 0) {
                 const showLen = Math.min(outLen, 256);
                 log(`\n[输出数据] (共${outLen}字节，显示前${showLen}字节)`);
                 log(hexdump(this.dataOutAddr, {
                     length: showLen,
                     header: false,
                     ansi: true,
                     format: 'hex+ascii'
                 }));
                 log(`输出长度: ${outLen}字节`);
             }
         }
  
         log('=== CCCrypt 调用结束 ===\n');
     }
 });
